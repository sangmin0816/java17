package sec1;

public class Example2 {
    public static void main(String[] args) {
        // 8bit = 1byte
        boolean a = true; // 논리형. 1바이트
        byte b = 127; // 바이트. 1바이트
        // 8진수(byte): -128~-1 and 0~127까지 표현함. 양수 범위를 벗어나는 것을 overflow라 부른다. 음수 범위를 벗어나는 것을 underflow라 부른다.
        char c = 'k'; // 문자. 2 바이트
        // 문자는 한 글자, 문자열은 두 글자 이상
        short d = 32767; // 반정도정수. 표현 범위: -32768~32767. 2바이트
        int e = 1234567890; // 단정도정수: 4바이트
        long f_var = 1234567890; // 배정도정수: 4바이트. C의 경우에는 8바이트임.

        System.out.printf("%b %d %c %d %d %d\n", a, b, c, d, e, f_var);
        // 표현범위는 -2의 (n-1)승 에서 2의(n-1)승 -1
        // 아주 큰 단위, 예컨대 금융 등에서 쓰이는 단위의 경우에는 클래스로 된 타입을 쓴다(ex. currency)

        // 실수(float): 부동소수점. 뜰 부를 사용함. 움직이는 소수점이다.
        float g = 1234567890; // 실수형. 그냥 쓰면 4 바이트.
        float gL = 1234567890123456789L;// L쓰면 8바이트로 확장됨
        float gF = 123456789012345678901234567890123456789.0f; // f쓰면 실수로 인식함. 단정도실수로 4바이트.
        // 10의 6승 * 348670 으로 저장된다. 부호부(+-)와 지수부와 가수부(소수점 이하)로 나뉘게 된다.
        double h = 123456789012345678901234567890123456789.0; // 배정도실수. 8바이트
        double hD = 1.0d; // 초정밀 데이터 저장. 그냥 double보다 더 많이 저장할 수 있다.
        // 하지만 큰 타입형을 쓰면 그만큼 시간이 많이 걸리기 때문에 규모에 따라 적절한 타입을 쓰는 것이 중요하다.
        System.out.println("g="+g+"\ngL="+gL+"\ngF="+gF+"\nh="+h+"\nhD="+hD);

        int n=0;
        System.out.println(n);
        // 이러한 데이터 타입을 기본 타입 primitive 타입알고 한다. 이들은 반드시 선언 후 값을 넣는 초기화를 진행해야 한다. 이들은 empty형태 즉 null 값이 허용되지 않는다.
    }
}
